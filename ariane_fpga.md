# Ariane on FPGAs

This document shows my progress trying to map ariane to a Diligent Zybo-Z7 FPGA (Xilinx ZYNQ 7020).

## Installing the requirements

After at least one (!) day of installing Vivado, RISCV-Tools and other tools I finally managed to simulate ariane and had a running instance of Vivado.

### RISCV-Tools

To install the RISCV-Tools and run ariane you can follow the [ariane quickstart guide](ariane_quickstart.md).

Note that ariane uses a forked `riscv-fesvr`. iI you already installed the original `riscv-tools` make sure that you install the [fork](https://github.com/pulp-platform/riscv-fesvr).

# Vivado

The installation of vivado is straight forward. 

In order to add support for the Diligent FPGA boards I also installed the [Diligent board files](https://reference.digilentinc.com/vivado/installing-vivado/start) and the [XDC constraints](https://github.com/Digilent/digilent-xdc).

## First Attempt

First I tried to directly map the ariane core to the FPGA. THis process has helped me to understand the structure or ariane and the synthesis of vivado. I added all sources (`src/`) to vivado and tried to synthesize it. Of course this did not work. I discovered that the file `src/ariane_wrapped.sv` is part of the testbench and not of ariane itself and it is not synthesizable. Additionally the definition of the `AXI_BUT` interface is missing. It can be found in `tb/agents/axi_if/axi_if.sv`.

With these two small changes the rtl of the core is correct and would be synthesizable if it were not for the caches. Ariane relies on L1 data and instruction caches and these must be generated by the Vivado blockmemory generator beforehand. Contrary to my intuition these memories are not generated with an AXI interface but with the native interface. The ariane codebase contains an interface module that connects arbitrary width native blockrams with an AXI bus. Sidenote: The Vivado blockram generator is not able to generate arbitrary width blockrams with an AXI interface (only 8, 16, 32, 64 and 128 bit) and since ariane needs a 48bit wide tag cache, it can only be generated with a native interface. 

In the end I managed to synthesize ariane with these four changes:
  - remove `ariane_wrapped.sv`
  - add `tb/agents/axi_if/axi_if.sv`
  - generate native blockram 256x128 (see [fpga/ips/xilinx_dcache_bank_data_256x128](fpga/ips/xilinx_dcache_bank_data_256x128))
  - generate native blockram 256x46 (see [fpga/ips/xilinx_dcache_bank_tag_256x46](fpga/ips/xilinx_dcache_bank_tag_256x46))

This design is obviously only synthesizable and not mappaple since it uses too many pins. This can be solved by a new top-level architecture around it similar to [pulpino](https://github.com/pulp-platform/pulpino) containing busses that are connected to certain peripherals and the DRAM.

## Rebase ontop of `ariane_next`

__TODO__


